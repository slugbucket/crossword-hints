from flask import Flask, request, flash, redirect, render_template, g, jsonify, Response, send_file, url_for
from werkzeug import Headers
from flask_login import LoginManager, UserMixin, current_user, \
                                login_required, login_user, logout_user
from jinja2 import Environment, PackageLoader, select_autoescape
from markupsafe import Markup, escape
from urllib.parse import urlparse, urljoin
#import sqlite3
import json
import os
import io
import re
# from peewee import *
import datetime
from datetime import date, timedelta, datetime
import ldap

# Print all queries to stderr.
#import logging
#logger = logging.getLogger('peewee')
#logger.addHandler(logging.StreamHandler())
#logger.setLevel(logging.DEBUG)

# To run the application as standalone,
# export FLASK_APP=crossword_hints.py
# flask run
# or, with uwsgi,
# uwsgi --ini crossword_hints.ini
#
application = Flask(__name__) or create_app('crossword_hints.py')
try:
    os.environ['APP_SETTINGS']
except KeyError:
    os.environ['APP_SETTINGS'] = os.path.join(application.root_path, 'default_settings.py')

# Create an application handle that AWS EB can understand
application.config.from_envvar('APP_SETTINGS')

## flask-login
#login_manager = LoginManager()
#login_manager.init_app(application)
#login_manager.login_view = "crossword_login"

#database = SqliteDatabase(application.config['DATABASE'], pragmas=(("foreign_keys", "on"),))
#database.row_factory = sqlite3.Row

# This hook ensures that a connection is opened to handle any queries
# generated by the request.
#@application.before_request
#def _db_connect():
#    #database.get_conn()


# This hook ensures that the connection is closed when we've finished
# processing the request.
@application.teardown_request
def _db_close(exc):
    if not database.is_closed():
        database.close()

def get_ldap_connection():
    conn = ldap.initialize(application.config['LDAP_PROVIDER_URL'])
    return conn

@login_manager.user_loader
def load_user(id):
    return users.get(users.rowid == int(id))

"""
Initialise the database - only to be used for testing and database restore
To bootstrap a database, either empty or with new schema:
$ python
>>> import crossword_hints
>>> from peewee import *
>>> with .application.app_context()@login_manager.user_loader
def load_user(id):
    return User.query.get(int(id)):
...     crossword_hints.init_db()
Params:
  None
Returns:
  None
"""
def init_db():
    #for tbl in ['setter_types', 'crossword_setters', 'solution_types', 'crossword_solutions']:
    #    database.execute_sql("drop table " + tbl)
    database.create_tables([setter_types, crossword_setters, solution_types, crossword_solutions, activity_logs, cue_words, users])

@application.route('/crossword-hints/heartbeat', methods=["GET"])
def heartbeat():
    return "OK"

"""
Site login
Params:
  None
Returns:
  jinja2 template render of the login form
"""
@application.route("/login", methods=['GET', 'POST'])
def crossword_login():
    try:
        if current_user.is_authenticated:
            flash('You are already logged in.')
            return redirect(request.path)
    except:
        pass

    if request.method == 'POST':
        username = request.form.get('username')
        password = request.form.get('password')

        try:
            users.try_login(username, password)
        except ldap.INVALID_CREDENTIALS:
            flash(
                'Invalid username or password. Please try again.', 'danger')
            add_log(username, 'login', 'user', '-1', ('Failed login for %s: invalid username or password.' % username))
            return(render_template('views/login/login.html', u=username, r=request))
        except ldap.SERVER_DOWN:
            flash(
                'Cannot contact LDAP server, login not possible.', 'danger')
            return(render_template('views/login/login.html', u=username, r=request))

        user = users.get(users.username == username)
        try:
            login_user(user)
            add_log(username, 'login', 'user', user.get_id(), ("Successful login for %s" % username))
        except Exception as e:
            add_log(username, 'login', 'user', user.get_id(), str(e))
        return redirect_back('crossowrd_hints_index')
    else:
        username = 'username'

    return(render_template('views/login/login.html', u=username, r=request))

# somewhere to logout
@application.route("/logout")
@login_required
def logout():
    u = users.get_name(current_user)
    add_log(u, 'logout', 'user', users.get_id(current_user), ("Successful logout for %s" % u))
    logout_user()
    flash("%s logout successful. Please close browser for best security." % u)
    return(redirect("/"))


"""
Index listing of known solutions
Params:
  None
Returns:
  jinja2 template render of list of active requests
"""
@application.route("/crossword-solutions/", defaults={'page': 1})
@application.route('/crossword-solutions/page/<int:page>')
@application.route('/crossword-solutions/search', methods=["POST"], defaults={'page': 1})
def crossword_solution_index(page):
    offset = ((int(page)-1) * application.config['PER_PAGE'])
    term = ''
    qtrm = '%'
    if request.method == "POST":
        (rc, fdata) = sanitize_input(request.form)
        term = fdata["search_box"]
        qtrm = "%" + term + "%"
    else:
        if request.args.get('q'):
            term = request.args.get('q')
            qtrm = "%" + term + "%"

    rs = crossword_setters.select(crossword_solutions.rowid.alias("csid"),
                           crossword_solutions.solution,
                           crossword_solutions.clue,
                           solution_types.name.alias("soltype"),
                           crossword_setters.name.alias("setter")) \
                          .join(crossword_solutions, JOIN.INNER, on=(crossword_setters.rowid == crossword_solutions.crossword_setter_id)) \
                          .join(solution_types, JOIN.INNER, on=(crossword_solutions.solution_type_id == solution_types.rowid)) \
                          .where(crossword_solutions.solution.contains(term) | \
                                 crossword_setters.name.contains(term) | \
                                 solution_types.name.contains(term)) \
                          .order_by(fn.Lower(crossword_solutions.solution)).dicts()
    count = len(rs)
    solutions = rs.paginate(page, application.config['PER_PAGE'])
    # Display a 409 not found page for an out of bounds request
    if not solutions and page != 1:
        return(render_template('errors/409.html', errmsg="Requested page out of bounds"), 409 )
    return(render_template('views/crossword-solutions/index.html',
                           r=request,
                           solns=solutions,
                           pagination=Pagination(page, application.config['PER_PAGE'], count), search_term=term))

"""
Display an existing solution
"""
@application.route("/crossword-solutions/<int:id>", methods=["GET"])
def crossword_solutions_show(id):
    rs = crossword_setters.select(crossword_solutions.rowid.alias("csid"),
                           crossword_solutions.solution,
                           crossword_solutions.clue,
                           crossword_solutions.solution_hint.alias("hint"),
                           solution_types.name.alias("soltype"),
                           crossword_setters.name.alias("setter")) \
                          .join(crossword_solutions, JOIN.INNER, on=(crossword_setters.rowid == crossword_solutions.crossword_setter_id)) \
                          .join(solution_types, JOIN.INNER, on=(crossword_solutions.solution_type_id == solution_types.rowid)) \
                          .where(crossword_solutions.rowid == id) \
                          .order_by(fn.Lower(crossword_solutions.solution)).tuples()
    for setter, solution, clue, hint, csid, soltype in rs:
        xsol = {"csid": csid, "setter": setter, "solution": solution, "clue": clue, "hint": hint, "soltype": soltype}
    return render_template('views/crossword-solutions/show.html', soln=xsol,  r=request)

"""
Add a new crossowrd solution
"""
@application.route("/crossword-solutions/new", methods=["GET", "POST"])
@login_required
def crossword_solutions_new():
    if request.method == "GET":
        solution={'clue': "Clue to the answer",
                  'solution': 'Thesolution',
                  'solution_hint': 'New solution hint',
                  'crossword_setter_id': 1,
                  'solution_type_id': 1}
        return render_template('views/crossword-solutions/new.html', soln=solution, s_types=get_solution_types(), setters=get_crossword_setters(), r=request, sbmt='Save new crossword solution')
    (rc, fdata) = sanitize_input(request.form)
    if not rc == "":
        flash(rc)
        return(render_template('views/crossword-solutions/new.html', soln=fdata, s_types=get_solution_types(), setters=get_crossword_setters(), r=request, sbmt=request.form['submit']))
    cs = crossword_solutions(crossword_setter_id=fdata['crossword_setter_id'],
                             clue=fdata['clue'],
                             solution=fdata['solution'],
                             solution_hint=fdata['solution_hint'],
                             solution_type_id=fdata['solution_type_id'],
                             created_at=datetime.now(),
                             updated_at=datetime.now())
    cs.save()
    log = ("crossword_setter_id: %s\nclue: %s\nsolution: %s\nsolution_hint: %s\nsolution_type_id: %s" %
          (fdata['crossword_setter_id'], fdata['clue'], fdata['solution'],
           fdata['solution_hint'], fdata['solution_type_id']))
    add_log(users.get_name(current_user), 'insert', 'crossword_solutions', cs.rowid, log)
    flash("Saved new crossword solution, %s" % fdata['solution'])
    return redirect('/crossword-solutions/')

"""
Edit an existing solution
"""
@application.route("/crossword-solutions/<int:id>/edit", methods=["GET", "POST"])
@login_required
def crossword_solutions_edit(id):
    if request.method == "GET":
        try:
            rs = crossword_solutions.get(crossword_solutions.rowid == id)
        except DoesNotExist:
            flash("Cannot find crossword solution record for id, %s." % id)
            return(redirect('/crossword-solutions'))
        return render_template('views/crossword-solutions/edit.html', soln=rs, s_types=get_solution_types(), setters=get_crossword_setters(), r=request, sbmt='Update crossword solution')
    (rc, fdata) = sanitize_input(request.form)
    if not rc == "":
        flash(rc)
        return(render_template('views/crossword-solutions/edit.html', solution=fdata, s_types=get_solution_types(), setters=get_crossword_setters(), r=request, sbmt=request.form['submit']))
    cs = crossword_solutions(rowid=id,
                             crossword_setter_id=fdata['crossword_setter_id'],
                             clue=fdata['clue'],
                             solution=fdata['solution'],
                             solution_hint=fdata['solution_hint'],
                             solution_type_id=fdata['solution_type_id'],
                             updated_at=datetime.now())
    cs.save()
    log = ("crossword_setter_id: %s\nclue: %s\nsolution: %s\nsolution_hint: %s\nsolution_type_id: %s" %
      (fdata['crossword_setter_id'], fdata['clue'], fdata['solution'],
       fdata['solution_hint'], fdata['solution_type_id']))
    add_log(users.get_name(current_user), 'update', 'crossword_solutions', id, log)
    flash("Updated crossword solution, %s" % fdata['solution'])
    return(redirect('/crossword-solutions'))

@application.route("/crossword-solutions/<int:id>/delete", methods=["GET"])
@login_required
def crossword_solutions_delete(id):
    try:
        rs = crossword_solutions.get(crossword_solutions.rowid == id)
    except DoesNotExist:
        flash("Cannot find solution record for id, %s." % id)
        return(redirect('/crossword-solutions'))
    log = ("crossword_setter_id: %s\nclue: %s\nsolution: %s\nsolution_hint: %s\nsolution_type_id: %s" %
      (rs.crossword_setter_id, rs.clue, rs.solution, rs.solution_hint, rs.solution_type_id))
    rs.delete_instance()
    add_log(users.get_name(current_user), 'delete', 'crossword_solutions', id, log)
    flash("Deleted crossword solution, %s" % rs.solution)
    return(redirect('/crossword-solutions'))

"""                                                   """
"""   C  R  O  S  S  W  O  R  D      H  I  N  T  S    """
"""                                                   """
@application.route("/crossword-hints/", methods=["GET", "POST"], defaults={'path': ''})
@application.route('/', methods=["GET", "POST"], defaults={'path': ''})
def crossowrd_hints_index(path):
    if request.method == "GET":
        return(render_template('views/crossword-hints/index.html', r=request))
    (rc, fdata) = sanitize_input(request.form)
    if not rc == "":
        flash(rc)
        return(render_template('views/crossword-hints/index.html', r=request, sbmt=request.form['submit']))

    clueset = crossword_setters.select(crossword_solutions.rowid.alias("csid"),
                           crossword_solutions.solution,
                           crossword_solutions.clue,
                           crossword_solutions.solution_hint.alias("hint"),
                           solution_types.name.alias("soltype"),
                           crossword_setters.name.alias("setter")) \
                          .join(crossword_solutions, JOIN.INNER, on=(crossword_setters.rowid == crossword_solutions.crossword_setter_id)) \
                          .join(solution_types, JOIN.INNER, on=(crossword_solutions.solution_type_id == solution_types.rowid)) \
                          .where(crossword_solutions.clue.contains(format(fdata['cue_word']))) \
                          .order_by(fn.Lower(crossword_solutions.solution)).dicts()
    return(render_template('views/crossword-hints/index.html', r=request, clues=clueset))

"""                                                    """
""" Search database for cue words matching search term """
""" JQuery is used to handle an AJAX request to search """
""" the database for a matching cue word. This submits """
""" via a GET request with a callback reference that   """
""" needs to be included in the response in JSONP      """
"""                                                    """
@application.route("/cue-words/", methods=["GET"])
def crossword_cue_search():
    callback = request.args.get('callback')
    if not callback or callback == "":
        return(render_template('errors/409.html', errmsg="Missing JQuery callback value"), 400)
    rs = cue_words.select(cue_words.rowid, cue_words.cue_word).where(cue_words.cue_word.contains(request.args['cue']))
    ary = {}
    for row in rs:
        ary[row.rowid] = row.cue_word
    ret = '{0}({1})'.format(callback, json.dumps(ary))
    return(Response(ret, mimetype="text/json"))

"""
Submit a new cue word to the database
"""
@application.route("/cue-words/new", methods=["GET", "POST"])
@login_required
def crossword_cue_new():
    if request.method == "GET":
        cue={'cue_word': "Cue word",
                  'meaning': 'Cue meaning'}
        return render_template('views/cuse-words/new.html', cue=cue, r=request, sbmt='Save new cue word')
    (rc, fdata) = sanitize_input(request.form)
    if not rc == "":
        flash(rc)
        return(render_template('views/cuse-words/new.html', cue=fdata, r=request, sbmt=request.form['submit']))
    cw = cue_words(cue_word=fdata['cue_word'], meaning=fdata['meaning'])
    cw.save()
    return(redirect('/crossword-hints'))

"""
Index listing of known setters
"""
@application.route("/crossword-setters/", methods=["GET"], defaults={'page': 1})
@application.route('/crossword-setters/page/<int:page>')
def crossword_setters_index(page):
    count = crossword_setters.select(fn.COUNT(crossword_setters.rowid)).scalar()
    offset = ((int(page)-1) * application.config['PER_PAGE'])
    rs = crossword_setters.select(crossword_setters.rowid, crossword_setters.name, crossword_setters.description, setter_types.name.alias('setter_type_name')).join(setter_types).where(crossword_setters.setter_type_id == setter_types.rowid).limit(application.config['PER_PAGE']).offset(offset).order_by(fn.Lower(crossword_setters.name))
    if not rs and page != 1:
        return(render_template('errors/409.html', errmsg="Requested page out of bounds"), 409 )
    return render_template('views/crossword-setters/index.html',
                           setters=rs.dicts(),
                           pagination=Pagination(page, application.config['PER_PAGE'], count),
                           r=request)

@application.route("/crossword-setters/<int:id>", methods=["GET"])
def crossword_setters_show(id):
    # Getting the setter id, name and setter_type name should be a simple inner
    # join across the tables but Peewee makes a complete mess of it by using get() which doesn't
    # seem to recognise aliases or joins.
    rs = crossword_setters.select(crossword_setters.rowid,
                            crossword_setters.name,
                            crossword_setters.description,
                            setter_types.name.alias('setter_type_name')) \
                        .join(setter_types, JOIN.INNER, on=(crossword_setters.setter_type_id == setter_types.rowid)) \
                        .where(crossword_setters.rowid == id).tuples()
    for id, sname, descrip, stname in rs:
        setter = {"rowid": id, "name": sname, "description": descrip, "setter_type_name": stname}
    return render_template('views/crossword-setters/show.html', setter=setter,  r=request)

"""
Add a new crossword setter
"""
@application.route("/crossword-setters/new", methods=["GET", "POST"])
@login_required
def crossword_setters_new():
    if request.method == "GET":
        setter={'name': "New setter", 'setter_type_id': 1}
        return render_template('views/crossword-setters/new.html', setter=setter, s_types=get_setter_types(), r=request, sbmt='Save new crossword setter')
    (rc, fdata) = sanitize_input(request.form)
    if not rc == "":
        flash(rc)
        return(render_template('views/crossword-setters/new.html', setter=fdata, s_types=get_setter_types(), r=request, sbmt=request.form['submit']))
    cs = crossword_setters(name=fdata['name'], setter_type_id=fdata['setter_type_id'], description=fdata['description'])
    cs.save()
    log = ("name: %s\nsetter_type_id: %s\ndescription: %s" %
          (fdata['name'], fdata['setter_type_id'], fdata['description']))
    add_log(users.get_name(current_user), 'insert', 'crossword_setters', cs.rowid, log)
    flash("Saved new crossword setter, %s" % fdata['name'])
    return redirect('/crossword-setters/')

"""
Edit an existing setter
"""
@application.route("/crossword-setters/<int:id>/edit", methods=["GET", "POST"])
@login_required
def crossword_setters_edit(id):
    if request.method == "GET":
        try:
            rs = crossword_setters.get(crossword_setters.rowid == id)
        except DoesNotExist:
            flash("Cannot find crossword setter record for id, %s." % id)
            return(redirect('/crossword-setters'))
        rs = crossword_setters.get(crossword_setters.rowid == id)
        return render_template('views/crossword-setters/edit.html', setter=rs, s_types=get_setter_types(), r=request, sbmt='Update crossword setter')
    (rc, fdata) = sanitize_input(request.form)
    if not rc == "":
        flash(rc)
        return(render_template('views/crossword-setters/edit.html', setter=fdata, r=request, sbmt=request.form['submit']))
    cs = crossword_setters(rowid=id, name=fdata['name'],
                           setter_type_id=fdata['setter_type_id'],
                           description=fdata['description'],
                           updated_at=datetime.now())
    cs.save()
    log = ("name: %s\nsetter_type_id: %s\ndescription: %s" %
          (fdata['name'], fdata['setter_type_id'], fdata['description']))
    add_log(users.get_name(current_user), 'update', 'crossword_setters', id, log)
    flash("Updated crossword setter, %s" % fdata['name'])
    return(redirect('/crossword-setters'))

"""
Delete an existing setter
"""
@application.route("/crossword-setters/<int:id>/delete", methods=["GET"])
@login_required
def crossword_setters_delete(id):
    try:
        rs = crossword_setters.get(crossword_setters.rowid == id)
    except DoesNotExist:
        flash("Cannot find crssword setter record for id, %s." % id)
        return(redirect('/crossword-setters/'))
    log = ("name: %s\nsetter_type_id: %s\ndescription: %s" %
          (rs.name, rs.setter_type_id, rs.description))
    rs.delete_instance()
    add_log(users.get_name(current_user), 'delete', 'crossword_setters', id, log)
    flash("Deleted crossword setter, %s" % rs.name)
    return(redirect('/crossword-setters/'))

"""              """
""" Setter types """
"""              """
@application.route("/setter-types/", methods=["GET"], defaults={'page': 1})
@application.route('/setter-types/page/<int:page>')
def setter_types_index(page):
    count = setter_types.select(fn.COUNT(setter_types.rowid)).scalar()
    offset = ((int(page)-1) * application.config['PER_PAGE'])
    rs = setter_types.select().limit(application.config['PER_PAGE']).offset(offset).order_by(fn.Lower(setter_types.name))
    if not rs and page != 1:
        return(render_template('errors/409.html', errmsg="Requested page out of bounds"), 409 )
    return render_template('views/setter-types/index.html',
                           stypes=rs.dicts(),
                           pagination=Pagination(page, application.config['PER_PAGE'], count),
                           r=request)

@application.route("/setter-types/<int:id>", methods=["GET"])
def setter_types_show(id):
    rs = setter_types.get(setter_types.rowid == id)
    return render_template('views/setter-types/show.html', stype=rs,  r=request)

@application.route("/setter-types/new", methods=["GET", "POST"])
@login_required
def setter_types_new():
    if request.method == "GET":
        stype={'name': "New setter type", 'description': 'Brief description of this type of setter'}
        return(render_template('views/setter-types/new.html', stype=stype,  r=request, sbmt='Save new setter type'))
    (rc, fdata) = sanitize_input(request.form)
    if not rc == "":
        flash(rc)
        return(render_template('views/setter-types/new.html', stype=fdata, r=request, sbmt=request.form['submit']))
    st = setter_types(name=fdata['name'], description=fdata['description'])
    st.save()
    log = ("name: %s\ndescription: %s" % (fdata['name'], fdata['description']))
    add_log(users.get_name(current_user), 'insert', 'setter_types', st.rowid, log)
    flash("Saved new setter type, %s" % fdata['name'])
    return redirect('/setter-types')


@application.route("/setter-types/<int:id>/edit", methods=["GET", "POST"])
@login_required
def setter_types_edit(id):
    if request.method == "GET":
        try:
            rs = setter_types.get(setter_types.rowid == id)
        except DoesNotExist:
            flash("Cannot find setter type record for id, %s." % id)
            return(redirect('/setter-types'))
        return(render_template('views/setter-types/edit.html', stype=rs, r=request, sbmt='Update setter type'))
    (rc, fdata) = sanitize_input(request.form)
    if not rc == "":
        flash(rc)
        return(render_template('views/setter-types/edit.html', stype=fdata, r=request, sbmt=request.form['submit']))
    st = setter_types(rowid=id, name=fdata['name'],
                      description=fdata['description'],
                      updated_at=datetime.now())
    st.save()
    log = ("name: %s\ndescription: %s" % (fdata['name'], fdata['description']))
    add_log(users.get_name(current_user), 'update]', 'setter_types', id, log)
    flash("Updated setter type, %s" % fdata['name'])
    return(redirect('/setter-types'))

@application.route("/setter-types/<int:id>/delete", methods=["GET"])
@login_required
def setter_types_delete(id):
    try:
        rs = setter_types.get(setter_types.rowid == id)
    except DoesNotExist:
        flash("Cannot find setter type record for id, %s." % id)
        return(redirect('/setter-types'))
    log = ("name: %s\ndescription: %s" % (rs.name, rs.description))
    rs.delete_instance()
    add_log(users.get_name(current_user), 'delete', 'setter_types', rs.rowid, log)
    flash("Deleted setter type, %s" % rs.name)
    return(redirect('/setter-types'))


"""               """
""" Solution types """
"""               """
@application.route("/solution-types/", methods=["GET"], defaults={'page': 1})
@application.route('/solution-types/page/<int:page>')
def solution_types_index(page):
    count = solution_types.select(fn.COUNT(solution_types.rowid)).scalar()
    offset = ((int(page)-1) * application.config['PER_PAGE'])
    rs = solution_types.select().limit(application.config['PER_PAGE']).offset(offset).order_by(fn.Lower(solution_types.name))
    if not rs and page != 1:
        return(render_template('errors/409.html', errmsg="Requested page out of bounds"), 409 )
    return render_template('views/solution-types/index.html',
                           stypes=rs.dicts(),
                           pagination=Pagination(page, application.config['PER_PAGE'], count),
                           r=request)

"""
Route for direct rendering of the solution-types table in response to an AJAX request
"""
@application.route("/solution-types/index.ajax.html", methods=["GET"])
def solution_types_index_ajax():
    rs = solution_types.select().order_by(fn.Lower(solution_types.name))
    return render_template('views/solution-types/_index.ajax.html', stypes=rs.dicts())

"""
Solution types JSON route for AJAX requests
"""
@application.route("/solution-types/index.json", methods=["GET"])
def solution_types_index_json():
    rs = solution_types.select().order_by(fn.Lower(solution_types.name)).dicts()
    if not rs:
        return(Response('{"result": "error"}', mimetype="text/json", status_code=400))
    res = []
    for row in rs:
        res.append(dict(row))
    return(jsonify(res))

"""
Render a template of the detail of a spefic solution type
"""
@application.route("/solution-types/<int:id>", methods=["GET"])
def solution_types_show(id):
    rs = solution_types.get(solution_types.rowid == id)
    return render_template('views/solution-types/show.html', stype=rs,  r=request)

"""
Display a form requesting the details of a new solution type
"""
@application.route("/solution-types/new", methods=["GET", "POST"])
@login_required
def solution_types_new():
    if request.method == "GET":
        stype={'name': "New solution type", 'description': 'Brief description of this type of solution'}
        return render_template('views/solution-types/new.html', stype=stype,  r=request, sbmt='Save new solution type')
    (rc, fdata) = sanitize_input(request.form)
    if not rc == "":
        flash(rc)
        return(render_template('views/solution-types/new.html', stype=fdata, r=request, sbmt=request.form['submit']))
    st = solution_types(name=fdata['name'], description=fdata['description'])
    st.save()
    log = ("name: %s\ndescription: %s" % (fdata['name'], fdata['description']))
    add_log(users.get_name(current_user), 'insert', 'solution_types', st.rowid, log)
    flash("Saved new solution type, %s" % fdata['name'])
    return redirect('/solution-types')

"""
Display a form to edit the details of an existing solution type
"""
@application.route("/solution-types/<int:id>/edit", methods=["GET", "POST"])
@login_required
def solution_types_edit(id):
    try:
        stype = solution_types.get(solution_types.rowid == id)
    except DoesNotExist:
        flash("Cannot find solution type record for id, %s." % id)
        return(redirect('/solution-types'))
    if request.method == "GET":
        return render_template('views/solution-types/new.html', stype=stype,  r=request, sbmt='Update solution type')
    (rc, fdata) = sanitize_input(request.form)
    if not rc == "":
        flash(rc)
        return(render_template('views/solution-types/edit.html', stype=fdata, r=request, sbmt=request.form['submit']))
    st = solution_types(rowid=id, name=fdata['name'],
                      description=fdata['description'],
                      updated_at=datetime.now())
    st.save()
    log = ("name: %s\ndescription: %s" % (fdata['name'], fdata['description']))
    add_log(users.get_name(current_user), 'update', 'solution_types', id, log)
    flash("Updated solution type, %s" % fdata['name'])
    return(redirect('/solution-types'))

"""
Delete an existing solution type
"""
@application.route("/solution-types/<int:id>/delete", methods=["GET", "POST"])
@login_required
def solution_types_delete(id):
    try:
        rs = solution_types.get(solution_types.rowid == id)
    except DoesNotExist:
        flash("Cannot find solution type record for id, %s." % id)
        return(redirect('/solution-types'))
    log = ("name: %s\ndescription: %s" % (rs.name, rs.description))
    rs.delete_instance()
    add_log(users.get_name(current_user), 'delete', 'solution_types', rs.rowid, log)
    flash("Deleted solution type, %s" % rs.name)
    return(redirect("/solution-types"))


"""                                                        """
"""  E  X  C  E  P  T  I  O  N    H  A  N  D  L  I  N  G   """
"""                                                        """
@application.errorhandler(DoesNotExist)
def handle_database_error(error):
    return(render_template('errors/409.html', errmsg=error), 409)
@application.errorhandler(409)
def handle_409_error(error):
    return(render_template('errors/409.html', errmsg=error), 409)
@application.errorhandler(OperationalError)
def handle_operational_error(error):
    return(render_template('errors/409.html', errmsg=error), 409)
@application.errorhandler(404)
def handle_opertional_error(error):
    return(render_template('errors/404.html', errmsg=error))
@application.errorhandler(500)
def handle_opertional_error(error):
    return(render_template('errors/500.html', errmsg=error))

"""                                                        """
"""  I  N  T  E  R  N  A  L    F  U  N  C  T  I  O  N  S   """
"""                                                        """

"""
Function to try to determine if a URL (typically passed as a next parameter
when logging in) is safe to redirect to.
Taken from http://flask.pocoo.org/snippets/62/ although the next parameter
is delivered by the query string rather than hidden form element
Params:
  target: string - URL to forward to
Returns:
  bool: True is the target is safe to redirect to, False otherwise
"""
def is_safe_url(target):
    ref_url = urlparse(request.host_url)
    test_url = urlparse(urljoin(request.host_url, target))
    return test_url.scheme in ('http', 'https') and \
           ref_url.netloc == test_url.netloc

"""
Function to try and determine a suitable referral point that is safe
to redirect the client back after an action such as login.
Params:

Returns:
  string: target URL
"""
def get_redirect_target():
    for target in request.args.get('next'), request.referrer:
        if not target:
            continue
        if is_safe_url(target):
            return target

"""
Function to verify that a submitted forward URL is safe to redirect to or
use a fallback address instead.
Params:
  endpoint: string - name of fallback location if next parameter is not
            found or is not safe
  values: list of values associated with the fallback target
Returns:
  target to redirect to
"""
def redirect_back(endpoint, **values):
    target = request.args['next']
    if not target or not is_safe_url(target):
        target = url_for(endpoint, **values)
    return redirect(target)

"""
Function to add an activity log record
The format of entries for activity logging are:
* rowid - auto-assigned unique id for the activity record
* actor - name of the user performing the operation
* action - one of login, insert, update, delete or logout,
* item_type -the table on which the operation has been performed.
* item_id - the numeric id of the item under operation
* activity - details of the content that has been changed
"""
def add_log(actor, action, item_type, item_id, activity):
    log = activity_logs(actor=actor,
                        action=action,
                        item_type=item_type,
                        item_id=item_id,
                        act_action=activity,
                        created_at=datetime.now(),
                        updated_at=datetime.now())
    log.save()

"""
Construct an array containing the setter_type rowid and name
suitable for use in a SELECT form element
"""
def get_setter_types():
    rs=setter_types.select(setter_types.rowid, setter_types.name).order_by(fn.Lower(setter_types.name))
    s_types = []
    for row in rs.dicts():
        s_types.append([row['rowid'], row['name']])
    return(s_types)

"""
Construct an array containing the crossword setter rowid and name
suitable for use in a SELECT form element
"""
def get_crossword_setters():
    cs=crossword_setters.select(crossword_setters.rowid, crossword_setters.name).order_by(fn.Lower(crossword_setters.name))
    setters = []
    for row in cs.dicts():
        setters.append([row['rowid'], row['name']])
    return(setters)

"""
Construct an array containing the solution_type rowid and name
suitable for use in a SELECT form element
"""
def get_solution_types():
    rs=solution_types.select(solution_types.rowid, solution_types.name).order_by(fn.Lower(solution_types.name))
    s_types = []
    for row in rs.dicts():
        s_types.append([row['rowid'], row['name']])
    return(s_types)

"""
Basic attempt to sanitize submitted form data
Attempt to validate all elements in the form data but if ny one element
is bd make sure the whole form is invalidated.
"""
def sanitize_input(form):
    data = {}
    rc = ""
    for elem in request.form:
        if elem == "name":
            (r, data[elem]) = validate_name(form[elem])
        elif re.match(r'^.*_id$', elem):
            (r, data[elem]) = validate_id(form[elem])
        else:
            (r, data[elem]) = validate_text(form[elem])
        if rc == "": rc = r
    return(rc, data)


def validate_name(str):
    if not re.match(r'^[a-zA-Z0-9-_.\' ()]*$', str):
        return("Invalid characters in name field: Only allowed a-zA-Z0-9-_. '", re.sub('[^a-zA-Z0-9-_\'. ]', "", str))
    return("", str)

def validate_text(str):
    return("", str)

"""
We expect submitted id values to be numeric
"""
def validate_id(str):
    try:
        int(str)
    except ValueError:
        return("id values must be numeric", "0")
    return("", str)

"""
Need to calculate the next rowid value for a table
"""
def nextId(tbl):
    return(database.execute_sql("SELECT MAX(rowid)+1 FROM %s" % tbl),scalar())

"""                                                        """
"""  D  A  T  A  B  A  S  E     M  O  D  E  L  L  I  N  G  """
"""                                                        """
"""                                                        """
"""     A base model that will use our Sqlite database.    """
"""     Appears to be incompatible with Flask TestCase     """
class BaseModel(Model):
    with application.app_context():
        class Meta:
            database = database

class activity_logs(BaseModel):
    rowid            = AutoField()
    actor            = CharField(max_length=32)
    action           = CharField(max_length=32)
    item_type        = CharField(max_length=32)
    item_id          = IntegerField()
    act_action       = TextField()
    created_at       = CharField(max_length=32)
    updated_at       = DateTimeField(default=datetime.now())

class setter_types(BaseModel):
    rowid            = AutoField()
    name             = CharField(null=False, max_length=16, unique=True)
    description      = TextField()
    created_at       = DateTimeField(default=datetime.now())
    updated_at       = DateTimeField(default=datetime.now())

class crossword_setters(BaseModel):
    rowid            = AutoField()
    name             = CharField(null=False, unique=True, max_length=32)
    setter_type      = ForeignKeyField(setter_types)
    description      = TextField()
    created_at       = DateTimeField(default=datetime.now())
    updated_at       = DateTimeField(default=datetime.now())

class solution_types(BaseModel):
    rowid            = AutoField()
    name             = CharField(null=False, unique=True, max_length=32)
    description      = TextField()
    created_at       = DateTimeField(default=datetime.now())
    updated_at       = DateTimeField(default=datetime.now())

class crossword_solutions(BaseModel):
    rowid            = AutoField()
    crossword_setter = ForeignKeyField(crossword_setters)
    clue             = CharField(null=False, max_length=96)
    solution         = CharField(null=False, max_length=128)
    solution_hint    = CharField(null=False, max_length=128)
    solution_type    = ForeignKeyField(solution_types)
    created_at       = DateTimeField(default=datetime.now())
    updated_at       = DateTimeField(default=datetime.now())

class cue_words(BaseModel):
    rowid            = AutoField()
    cue_word         = CharField(null=False, max_length=32)
    created_at       = DateTimeField(default=datetime.now())
    updated_at       = DateTimeField(default=datetime.now())

class users(BaseModel):
    rowid            = AutoField()
    username         = CharField(null=False, max_length=32, unique=True)
    created_at       = DateTimeField(default=datetime.now())
    updated_at       = DateTimeField(default=datetime.now())

    #def __init__(self, username, password):
    #    self.username = username

    @staticmethod
    def try_login(username, password):
        conn = get_ldap_connection()
        conn.simple_bind_s(
            'uid=%s,ou=People,dc=my-domain,dc=com' % username, password
        )

    def is_authenticated(self):
        return True

    def is_active(self):
        return True

    def is_anonymous(self):
        return False

    def get_id(self):
        return(self.rowid)

    def get_name(self):
        return(self.username)

"""                                             """
"""  E N D   O F   D A T A B A S E   M O D E L  """
"""                                             """

"""                                          """
"""  P A G I N A T I O N    C L A S S        """
"""                                          """
""" From http://flask.pocoo.org/snippets/44/ """
"""                                          """
class Pagination(object):

    def __init__(self, page, per_page, total_count):
        self.page = page
        self.per_page = per_page
        self.total_count = total_count

    @property
    def pages(self):
        return int(ceil(self.total_count / float(self.per_page)))

    @property
    def has_prev(self):
        return self.page > 1

    @property
    def has_next(self):
        return self.page < self.pages

    def iter_pages(self, left_edge=2, left_current=2,
                   right_current=5, right_edge=2):
        last = 0
        for num in range(1, self.pages + 1):
            if num <= left_edge or \
               (num > self.page - left_current - 1 and \
                num < self.page + right_current) or \
               num > self.pages - right_edge:
                if last + 1 != num:
                    yield None
                yield num
                last = num

""" Pagination view helpers             """
""" http://flask.pocoo.org/snippets/44/ """
def url_for_other_page(page):
    args = request.view_args.copy()
    args['page'] = page
    return url_for(request.endpoint, **args)
application.jinja_env.globals['url_for_other_page'] = url_for_other_page

"""                                                  """
"""  E N D   O F   P A G I N A T I O N    C L A S S  """
"""                                                  """
